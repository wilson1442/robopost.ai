# robopost.ai Architecture Documentation

## System Overview

robopost.ai follows a **control plane pattern** where the Next.js application serves as the user interface and configuration layer, while n8n acts as the **system of intelligence** handling all AI operations.

### Core Principle

```
Next.js App (Control Plane) → Webhook → n8n (Intelligence Layer) → Results → Next.js App (Display)
```

The application is **stateless** and **serverless**, designed for Vercel deployment. All AI inference, content synthesis, and orchestration occurs in n8n workflows triggered by outbound webhooks.

## Architecture Boundaries

### Next.js Application Boundary

**Responsible for:**
- User interface and UX
- Configuration management (RSS metadata, schedules, prompts)
- Webhook triggering (outbound only)
- Result storage and display
- Authentication and authorization

**NOT responsible for:**
- AI model calls
- Prompt construction logic
- Content synthesis
- RSS feed fetching/parsing
- Model selection

### n8n Boundary (External)

**Responsible for:**
- RSS feed fetching and parsing
- AI agent execution
- Prompt construction and management
- Content synthesis and formatting
- Multi-output generation
- Optional downstream posting (social, email, webhooks)

### Strict Separation

- No AI model calls from Next.js
- No prompt logic in Next.js
- No content synthesis in Next.js
- Next.js only formats user input into structured webhook payloads

## Data Flow Architecture

```
User → Next.js App → Supabase (Config Storage)
                ↓
         Outbound Webhook
                ↓
         n8n Workflow
                ↓
    [Fetch RSS → AI Agents → Synthesize]
                ↓
         Inbound Webhook
                ↓
    Next.js App → Supabase (Results)
                ↓
              User
```

## Webhook Contract

### Outbound Webhook Payload (Next.js → n8n)

**Endpoint:** Configurable via environment variable (`N8N_WEBHOOK_URL`)  
**Method:** POST  
**Content-Type:** application/json  
**Version:** v1

```typescript
interface OutboundWebhookPayload {
  version: "v1";
  runId: string;                    // UUID generated by Next.js
  userId: string;                   // Supabase user ID
  timestamp: string;                // ISO 8601
  config: {
    industry: string;               // Selected industry identifier
    rssSources: Array<{
      id: string;                   // RSS source ID from database
      url: string;                  // RSS feed URL
      name: string;                 // User-friendly name
    }>;
    promptInstructions: string;      // User-provided prompt customization
    outputFormats: Array<"blog" | "social" | "email" | "webhook">;
    destination: {
      type: "webhook" | "social" | "email" | "none";
      config?: {
        webhookUrl?: string;
        socialPlatforms?: string[];
        emailRecipients?: string[];
      };
    };
    schedule?: {
      cronExpression: string;        // For future scheduled runs
    };
  };
}
```

### Inbound Webhook Payload (n8n → Next.js)

**Endpoint:** `/api/webhooks/callback`  
**Method:** POST  
**Content-Type:** application/json  
**Authentication:** HMAC signature (optional, Phase 2+)

```typescript
interface InboundWebhookPayload {
  version: "v1";
  runId: string;                    // Echoed from outbound payload
  status: "success" | "partial" | "error";
  timestamp: string;                 // ISO 8601
  results: Array<{
    outputType: "blog" | "social" | "email" | "webhook";
    content: string;                 // Generated content
    metadata: {
      sources: Array<{
        url: string;
        title: string;
        publishedAt: string;
      }>;
      model?: string;                // n8n internal (optional)
      tokensUsed?: number;           // n8n internal (optional)
    };
  }>;
  error?: {
    code: string;
    message: string;
    details?: unknown;
  };
}
```

### Webhook Flow Sequence

1. User configures run in Next.js app
2. Next.js generates unique `runId` (UUID)
3. Next.js stores run record in Supabase with status "pending"
4. Next.js sends POST request to n8n webhook URL with payload
5. n8n workflow receives payload and processes:
   - Fetches RSS feeds from provided URLs
   - Executes AI agents with user prompt instructions
   - Synthesizes content into requested formats
   - Formats results into response payload
6. n8n sends POST request to Next.js callback endpoint with results
7. Next.js updates run record in Supabase with status "completed"
8. Next.js stores results in `agent_results` table
9. Next.js displays results to user

## Data Model (Supabase Schema)

### Tables

#### `users` (Supabase Auth)
- Handled by Supabase Auth extension
- Additional profile fields in `user_profiles`

#### `user_profiles`
- `id` (uuid, FK → auth.users, PK)
- `created_at` (timestamp)
- `updated_at` (timestamp)
- `industry_preference` (text, nullable)

#### `industries`
- `id` (uuid, PK)
- `slug` (text, unique)
- `name` (text)
- `description` (text, nullable)
- `default_prompt_template` (text, nullable) - Reference only, not used by Next.js

#### `rss_sources`
- `id` (uuid, PK)
- `url` (text, unique)
- `name` (text)
- `industry_id` (uuid, FK → industries, nullable)
- `is_public` (boolean, default false)
- `created_at` (timestamp)
- `updated_at` (timestamp)

#### `user_sources` (Junction table)
- `id` (uuid, PK)
- `user_id` (uuid, FK → auth.users)
- `rss_source_id` (uuid, FK → rss_sources)
- `custom_name` (text, nullable)
- `is_active` (boolean, default true)
- `created_at` (timestamp)

#### `agent_runs`
- `id` (uuid, PK) - Used as runId in webhooks
- `user_id` (uuid, FK → auth.users)
- `status` (text: 'pending' | 'processing' | 'completed' | 'failed')
- `industry_id` (uuid, FK → industries, nullable)
- `prompt_instructions` (text, nullable)
- `triggered_at` (timestamp)
- `completed_at` (timestamp, nullable)
- `error_message` (text, nullable)
- `webhook_payload` (jsonb) - Outbound payload snapshot
- `created_at` (timestamp)

#### `agent_results`
- `id` (uuid, PK)
- `run_id` (uuid, FK → agent_runs)
- `output_type` (text: 'blog' | 'social' | 'email' | 'webhook')
- `content` (text)
- `metadata` (jsonb) - Sources, model info, etc.
- `created_at` (timestamp)

#### `schedules`
- `id` (uuid, PK)
- `user_id` (uuid, FK → auth.users)
- `name` (text)
- `cron_expression` (text)
- `industry_id` (uuid, FK → industries, nullable)
- `rss_source_ids` (uuid[], array of rss_sources.id)
- `prompt_instructions` (text, nullable)
- `output_formats` (text[])
- `destination_config` (jsonb)
- `is_active` (boolean, default true)
- `next_run_at` (timestamp, nullable)
- `last_run_id` (uuid, FK → agent_runs, nullable)
- `created_at` (timestamp)
- `updated_at` (timestamp)

#### `webhook_configs` (Future: custom n8n endpoints)
- `id` (uuid, PK)
- `user_id` (uuid, FK → auth.users)
- `name` (text)
- `webhook_url` (text)
- `is_active` (boolean, default true)
- `created_at` (timestamp)

### Relationships

```
users (auth) 1:1 user_profiles
users 1:N user_sources
users 1:N agent_runs
users 1:N schedules
users 1:N webhook_configs

industries 1:N rss_sources
industries 1:N agent_runs
industries 1:N schedules

rss_sources N:M users (via user_sources)

agent_runs 1:N agent_results
schedules 1:1 agent_runs (last_run_id)
```

## Key Architectural Decisions

### 1. Global CSS Enforcement
**Decision:** Single `app/globals.css` file, no page-level CSS modules  
**Rationale:** Ensures consistent design tokens, easier maintenance, and prevents style fragmentation

### 2. Stateless Webhook Pattern
**Decision:** Generate runId in Next.js, include full config in payload  
**Rationale:** n8n workflows are stateless; all context must be in the payload. Enables idempotency and retry logic.

### 3. Payload Versioning
**Decision:** Include `version: "v1"` in all webhook payloads  
**Rationale:** Allows n8n workflows to evolve independently while maintaining backward compatibility

### 4. Result Storage Strategy
**Decision:** Store both webhook payloads and results in Supabase for audit trail  
**Rationale:** Enables debugging, analytics, and user history without querying n8n

### 5. RSS Source Management
**Decision:** Store RSS URLs and metadata in Supabase, but never fetch/parse in Next.js  
**Rationale:** Maintains clear boundary - Next.js manages configuration, n8n handles execution

### 6. Schedule Storage Only
**Decision:** Store cron expressions in database, but execution happens in n8n (or external scheduler)  
**Rationale:** Next.js is serverless and stateless; cannot run cron jobs. n8n or external service handles scheduling.

### 7. TypeScript Strict Mode
**Decision:** Use TypeScript with strict type checking  
**Rationale:** Prevents runtime errors, improves developer experience, ensures webhook contract compliance

### 8. Environment-Based Configuration
**Decision:** All external URLs (n8n, Supabase) via environment variables  
**Rationale:** Supports different environments (dev, staging, prod) without code changes

## Security Considerations

### Webhook Authentication (Phase 2+)

- **Outbound (Next.js → n8n):** Optional API key or token in headers
- **Inbound (n8n → Next.js):** HMAC signature verification using shared secret

### Data Privacy

- User data stored in Supabase with Row Level Security (RLS)
- RSS feed URLs are user-provided and stored as-is
- Generated content stored in Supabase, user-owned
- No AI model credentials stored in Next.js app

## Deployment

### Vercel Configuration

- Framework: Next.js
- Build Command: `npm run build`
- Output Directory: `.next`
- Install Command: `npm install`

### Environment Variables

Required for Phase 2+:
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SUPABASE_SERVICE_ROLE_KEY`
- `N8N_WEBHOOK_URL`
- `N8N_WEBHOOK_SECRET` (optional, for HMAC verification)

## Future Considerations

### Scalability

- Webhook processing is stateless and can scale horizontally
- Supabase handles database scaling
- n8n workflows can be distributed across multiple instances

### Monitoring

- Track webhook success/failure rates
- Monitor Supabase query performance
- Log webhook payloads for debugging (sanitized)

### Error Handling

- Retry logic for failed webhook calls
- Graceful degradation if n8n is unavailable
- User-friendly error messages without exposing internals

